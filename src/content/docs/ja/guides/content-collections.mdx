---
title: コンテンツコレクション
description: >-
  コンテンツコレクションは、Markdownを整理し、フロントマターをスキーマで型チェックするのに役立ちます。
i18nReady: true
---
import FileTree from '~/components/FileTree.astro'
import Since from '~/components/Since.astro'
import TypeScriptSettingTabs from '~/components/tabs/TypeScriptSettingTabs.astro'
import RecipeLinks from "~/components/RecipeLinks.astro"


<p>
  <Since v="2.0.0" />
</p>

**Content collections** are the best way to manage and author content in any Astro project. Collections help to organize your documents, validate your frontmatter, and provide automatic TypeScript type-safety for all of your content.

**コンテンツコレクション**は、Astroプロジェクトでコンテンツを管理し、オーサリングするもっとも良い方法です。コレクションはドキュメントを整理し、フロントマターを検証、すべてのコンテンツに対して自動的にTypeScriptの型安全性を提供します。

## What are Content Collections?

## コンテンツコレクションとは？

A **content collection** is any top-level directory inside the reserved `src/content` project directory, such as `src/content/newsletter` and `src/content/authors`. Only content collections are allowed inside the `src/content` directory. This directory cannot be used for anything else.

1つの**コンテンツコレクション**は、予約されているプロジェクトディレクトリ`src/content`の中にあるトップレベルのディレクトリです。たとえば`src/content/newsletter`や`src/content/authors`などになります。`src/content`ディレクトリの中に入れられるのは、コンテンツコレクションだけです。このディレクトリは他のものには使えません。

A **collection entry** is any piece of content stored inside of your content collection directory. Entries can use content authoring formats including Markdown (`.md`) and MDX (`.mdx` using the [MDX integration](/en/guides/integrations-guide/mdx/)) or as data formats including YAML (`.yaml`) and JSON (`.json`). We recommend using a consistent naming scheme (lower-case, dashes instead of spaces) for your files to make it easier to find and organize your content, but this is not required. You can also [exclude entries from being built](/en/core-concepts/routing/#excluding-pages) by prefixing the filename with an underscore (_).

**コレクションエントリー**は、コンテンツコレクションディレクトリ内に保存されたコンテンツのことです。エントリーには、Markdown（`.md`）やMDX （`.mdx` [MDXインテグレーション](/en/guides/integrations-guide/mdx/)を使用）などのコンテンツオーサリングフォーマットや、YAML（`.yaml`）やJSON（`.json`）などのデータフォーマットを使用できます。コンテンツの検索と整理を容易にするため、ファイルには一貫性のある命名スキーム（小文字、スペースの代わりにダッシュ）の使用をおすすめしますが、これは必須ではありません。また、ファイル名の前にアンダースコア（_）を付けることで、[ビルド対象からエントリーを除外](/en/core-concepts/routing/#excluding-pages)できます。

<FileTree>
- src/content/
  - **newsletter/** "newsletter"コレクション
    - week-1.md コレクションエントリー
    - week-2.md コレクションエントリー
    - week-3.md コレクションエントリー
</FileTree>

Once you have a collection, you can start [querying your content](#querying-collections) using Astro's built-in content APIs.

コレクションができたら、Astroの組み込みコンテンツAPIを使用して[コンテンツのクエリ](#querying-collections)を開始できます。

### The ".astro" Directory

### ".astro"ディレクトリ

Astro stores important metadata for content collections in an `.astro` directory in your project. No action is needed on your part to maintain or update this directory. You are encouraged to ignore it entirely while working in your project.

Astroは、コンテンツコレクションの重要なメタデータを、プロジェクト内の`.astro`ディレクトリに保存します。このディレクトリを維持または更新するために、あなたが何かする必要はありません。プロジェクトでの作業中は、このディレクトリを完全に無視することをおすすめします。

The `.astro` directory will be updated for you automatically anytime you run the [`astro dev`](/en/reference/cli-reference/#astro-dev), [`astro build`](/en/reference/cli-reference/#astro-build) commands. You can run [`astro sync`](/en/reference/cli-reference/#astro-sync) at any time to update the `.astro` directory manually.

`.astro`ディレクトリは、[`astro dev`](/en/reference/cli-reference/#astro-dev)コマンドや[`astro build`](/en/reference/cli-reference/#astro-build)コマンドを実行すると常に自動的に更新されます。手動で`.astro`ディレクトリを更新するために、必要に応じて[`astro sync`](/en/reference/cli-reference/#astro-sync)を実行できます。


:::tip
If you're using Git for version control, we recommend ignoring the `.astro` directory by adding `.astro` to your `.gitignore`. This tells Git to ignore this directory and any files inside of it.

バージョン管理にGitを使っている場合は、`.gitignore`に `.astro`を追加して`.astro`ディレクトリを無視することをおすすめします。次のコマンドは、このディレクトリとその中のファイルを無視するようにGitに指示します。

```bash
echo "\n.astro" >> .gitignore
```
:::



### Organizing with multiple collections 

### 複数のコレクションによる整理

If two files represent different kinds of content (e.g. a blog post and an author profile), they most likely belong in different collections. This is important because many features (frontmatter validation, automatic TypeScript type-safety) require that all entries in a collection share a similar structure.

2つのファイルが異なる種類のコンテンツ(例えばブログの投稿と著者のプロフィール)を表す場合、それらは異なるコレクションに属する可能性が高いでしょう。多くの機能（フロントマターの検証、TypeScriptの自動型安全性）では、コレクション内のすべてのエントリーが同様の構造を共有する必要があるため、これは重要です。

If you find yourself working with different types of content, you should create multiple collections to represent each type. You can create as many different collections in your project as you'd like.

さまざまなタイプのコンテンツを扱うことになったら、それぞれのタイプを表す複数のコレクションを作成する必要があります。プロジェクトには、いくつでも異なるコレクションを作成できます。

<FileTree>
- src/content/
  - **newsletter/**
    - week-1.md
    - week-2.md
  - **blog/**
    - post-1.md
    - post-2.md
  - **authors/**
    - grace-hopper.json
    - alan-turing.json
</FileTree>


### Organizing with subdirectories

### サブディレクトリを使った整理

A content collection is always a top-level folder inside of the `src/content/` directory. You cannot nest one collection inside of another. However, you can use subdirectories to organize your content within a collection.

コンテンツコレクションは、常に`src/content/`ディレクトリ内のトップレベルのフォルダです。コレクションを別のコレクションの中に入れ子にはできません。しかし、サブディレクトリを使ってコレクション内のコンテンツを整理できます。

For example, you can use the following directory structure to organize i18n translations within a single `docs` collection. When you query this collection, you'll be able to filter the result by language using the file path. 

たとえば、1つのdocsコレクション内で国際化翻訳を整理するために、次のディレクトリ構造を使えます。このコレクションをクエリするとき、ファイルパスを使用して言語によって結果をフィルタできます。

<FileTree>
- src/content/
  - docs/ このコレクションは、言語別に整理したサブディレクトリを使用
    - **en/**
    - **es/**
    - **de/**
</FileTree>

## Defining Collections

## コレクションの定義

:::note
The `src/content/config.ts` file is optional. However, choosing not to define your collections will disable some of their best features like frontmatter schema validation or automatic TypeScript typings. 

`src/content/config.ts`ファイルは省略できます。しかし、コレクションを定義しないと、フロントマターのスキーマ検証やTypeScriptの自動型付けなど、コレクションのいくつかの優れた機能が使えなくなります。
:::

To get the most out of your content collections, create a `src/content/config.ts` file in your project (`.js` and `.mjs` extensions are also supported.) This is a special file that Astro will automatically load and use to configure your content collections.

コンテンツコレクションを最大限に活用するには、プロジェクト内に`src/content/config.ts`ファイルを作成してください（`.js`と`.mjs`の拡張子もサポートされています）。これは、Astroがコンテンツコレクションを設定するために自動的に読み込んで使用する特別なファイルです。

```ts
// src/content/config.ts
// 1. `astro:content`からユーティリティをインポート
import { defineCollection } from 'astro:content';
// 2. コレクションを定義
const blogCollection = defineCollection({ /* ... */ });
// 3. コレクションを登録するために、単一の`collections`オブジェクトをエクスポート
//    このキーは、"src/content"のコレクションのディレクトリ名と一致する必要があります。
export const collections = {
  'blog': blogCollection,
};
```


### Setting up TypeScript

### TypeScriptのセットアップ

If you **do not** already extend Astro's `strict` or `strictest` recommended TypeScript settings in your `tsconfig.json` file, you may need to update your `tsconfig.json` to enable `strictNullChecks`.

`tsconfig.json`ファイルでAstroの推奨TypeScript設定を`strict`または`strictest`に設定**していない**場合は、`tsconfig.json`を更新して`strictNullChecks`を有効にする必要があるかもしれません。

```json title="tsconfig.json" ins={5}
{
  // 注意："astro/tsconfigs/strict"または"astro/tsconfigs/strictest"を使用する場合は変更する必要はありません。
  "extends": "astro/tsconfigs/base",
  "compilerOptions": {
    "strictNullChecks": true
  }
}
```

If you use `.js` or `.mjs` files in an Astro project, you can enable IntelliSense and type checking in your editor by enabling `allowJs` in your `tsconfig.json`:

Astroプロジェクトで`.js`または`.mjs`ファイルを使用する場合、`tsconfig.json`で`allowJs`を有効にすることで、インテリセンスとエディタでの型チェックを有効にできます。

```json title="tsconfig.json" ins={6}
{
  // 注意："astro/tsconfigs/strict"または"astro/tsconfigs/strictest"を使用する場合は変更する必要はありません。
  "extends": "astro/tsconfigs/base",
  "compilerOptions": {
    "strictNullChecks": true,
    "allowJs": true
  }
}
```

### Defining a collection schema

### コレクションスキーマの定義

Schemas enforce consistent frontmatter or entry data within a collection. A schema **guarantees** that this data exists in a predictable form when you need to reference or query it. If any file violates its collection schema, Astro will provide a helpful error to let you know.

スキーマは、コレクション内の一貫したフロントマターまたはエントリーデータを強制します。スキーマは、参照やクエリが必要なときに、このデータが予測可能な形で存在することを**保証**します。ファイルがコレクションスキーマに違反している場合、Astroは有用なエラーを表示してお知らせします。

Schemas also power Astro's automatic TypeScript typings for your content. When you define a schema for your collection, Astro will automatically generate and apply a TypeScript interface to it. The result is full TypeScript support when you query your collection, including property autocompletion and type-checking. 

スキーマはAstroのコンテンツに対する自動的なTypeScriptの型付けにも力を発揮します。コレクションにスキーマを定義すると、Astroは自動的にTypeScriptインターフェイスを生成して適用します。その結果、コレクションをクエリする際には、プロパティの自動補完や型チェックを含むTypeScriptが完全にサポートされます。

To define your first collection, create a `src/content/config.ts` file if one does not already exist (`.js` and `.mjs` extensions are also supported.) This file should:

最初のコレクションを定義するには、`src/content/config.ts`ファイルがまだ存在しない場合は、このファイルを作成します（`.js`と `.mjs`の拡張子もサポートされています）。

1. **Import the proper utilities** from `astro:content`. 
2. **Define each collection that you'd like to validate.** This includes a `type` (introduced in Astro v2.5.0) specifying whether the collection contains content authoring formats like Markdown (`type: 'content'`) or data formats like JSON or YAML (`type: 'data'`). It also includes a `schema` that defines the shape of your frontmatter or entry data.
3. **Export a single `collections` object** to register your collections.

1. `astro:content`から**適切なユーティリティをインポートします**。
2. **検証したい各コレクションを定義します**。これには、コレクションがMarkdownのようなコンテンツオーサリングフォーマット（`type: 'content'`）を含むか、JSONやYAMLのようなデータフォーマット（`type: 'data'`）を含むかを指定するタイプ（Astro v2.5.0で導入）が含まれます。また、フロントマターやエントリーデータの形を定義する`schema`も含まれます。
3. コレクションを登録するために、**単一のコレクションオブジェクトをエクスポートします**。

```ts
// src/content/config.ts
// 1. ユーティリティを`astro:content`からインポート
import { z, defineCollection } from 'astro:content';

// 2. 各コレクションに`type`と`schema`を定義
const blogCollection = defineCollection({
  type: 'content', // v2.5.0以降
  schema: z.object({
    title: z.string(),
    tags: z.array(z.string()),
    image: z.string().optional(),
  }),
});

// 3. コレクションを登録するために、単一の`collections`オブジェクトをエクスポート
export const collections = {
  'blog': blogCollection,
};
```

### Defining multiple collections

### 複数のコレクションの定義

You can use `defineCollection()` as many times as you want to create multiple schemas.  All collections must be exported from inside the single `collections` object.

`defineCollection()`は、複数のスキーマを作成するために何度でも使えます。 すべてのコレクションは、単一のコレクション・オブジェクトの内部からエクスポートする必要があります。

```ts
// src/content/config.ts
const blogCollection = defineCollection({
  type: 'content',
  schema: z.object({ /* ... */ })
});
const newsletter = defineCollection({
  type: 'content',
  schema: z.object({ /* ... */ })
});
const authors = defineCollection({
  type: 'data',
  schema: z.object({ /* ... */ })
});

export const collections = {
  'blog': blogCollection,
  'newsletter': newsletter,
  'authors': authors,
};
```

As your project grows, you are also free to reorganize your codebase and move logic out of the `src/content/config.ts` file. Defining your schemas separately can be useful for reusing schemas across multiple collections and sharing schemas with other parts of your project.

プロジェクトが成長するにつれて、コードベースを再編成し、src/content/config.tsファイルからロジックを移動することも自由にできます。スキーマを別々に定義することは、複数のコレクションでスキーマを再利用したり、プロジェクトの他の部分とスキーマを共有したりするのに便利です。

```ts
// src/content/config.ts
// 1. ユーティリティとスキーマのインポート
import { defineCollection } from 'astro:content';
import { blogSchema, authorSchema } from '../schemas';

// 2. コレクションを定義
const blogCollection = defineCollection({
  type: 'content',
  schema: blogSchema,
});
const authorCollection = defineCollection({
  type: 'data',
  schema: authorSchema,
});

// 3. 複数のコレクションをエクスポートして登録
export const collections = {
  'blog': blogCollection,
  'authors': authorCollection,
};
```

### Using third-party collection schemas

### サードパーティのコレクションスキーマの使用

You can import collection schemas from anywhere, including external npm packages. This can be useful when working with themes and libraries that provide their own collection schemas for you to use.

外部のnpmパッケージなど、どこからでもコレクションスキーマをインポートできます。これは、独自のコレクションスキーマを提供するテーマやライブラリを使用するときに便利です。

```ts
// src/content/config.ts
import { blogSchema } from 'my-blog-theme';
const blogCollection = defineCollection({ type: 'content', schema: blogSchema });

// 外部スキーマを使用して、ブログコレクションを'my-blog-theme'からエクスポート
export const collections = {
  'blog': blogCollection,
};
```


### Defining datatypes with Zod

### Zodによるデータ型の定義

Astro uses [Zod](https://github.com/colinhacks/zod) to power its content schemas. With Zod, Astro is able to validate every file's frontmatter within a collection *and* provide automatic TypeScript types when you go to query content from inside your project.

AstroはZodを使ってコンテンツスキーマを動かしています。Zodを利用すると、Astroはコレクション内のすべてのファイルのフロントマターを検証し、プロジェクト内からコンテンツをクエリする際に自動的にTypeScriptの型を提供できます。

To use Zod in Astro, import the `z` utility from `"astro:content"`. This is a re-export of the Zod library, and it supports all of the features of Zod. See [Zod’s README](https://github.com/colinhacks/zod) for complete documentation on how Zod works and what features are available.

AstroでZodを使うには、`"astro:content"`から`z`ユーティリティをインポートします。これはZodライブラリの再エクスポートで、Zodのすべての機能をサポートしています。Zodがどのように動作し、どのような機能が利用可能かについての完全なドキュメントは、[ZodのREADME](https://github.com/colinhacks/zod)を参照してください。

```ts
// 例：一般的なゾッドのデータ型のチートシート
import { z, defineCollection } from 'astro:content';

defineCollection({
  schema: z.object({
    isDraft: z.boolean(),
    title: z.string(),
    sortOrder: z.number(),
    image: z.object({
      src: z.string(),
      alt: z.string(),
    }),
    author: z.string().default('Anonymous'),
    language: z.enum(['en', 'es']),
    tags: z.array(z.string()),
    // オプションのフロントマター・プロパティ。非常に一般的です！
    footnote: z.string().optional(),
    // フロントマターでは、引用符で囲まずに書かれた日付はDateオブジェクトとして解釈されます。
    publishDate: z.date(),
    // 日付文字列（例えば "2022-07-08"）をDateオブジェクトに変換できます。
    // publishDate: z.string().transform((str) => new Date(str)),
    // 応用編：文字列が電子メールであることを検証する
    authorContact: z.string().email(),
    // 応用編：文字列がURLであることを検証する
    canonicalURL: z.string().url(),
  })
})
```

### Defining collection references

### コレクション参照の定義

Collection entries can also "reference" other related entries. 

コレクションエントリーは、他の関連するエントリーを「参照」することもできます。

With the `reference()` function from the Collections API, you can define a property in a collection schema as an entry from another collection. For example, you can require that every `space-shuttle` entry includes a `pilot` property which uses the `pilot` collection's own schema for type checking, autocomplete, and validation.

Collections APIの`reference()`関数を使うと、コレクションスキーマのプロパティを別のコレクションのエントリーとして定義できます。たとえば、すべての`space-shuttle`エントリーに、型チェック、オートコンプリート、バリデーションに`pilot`コレクションのスキーマを使用する`pilot`プロパティを含めるように要求できます。

A common example is a blog post that references reusable author profiles stored as JSON, or related post URLs stored in the same collection:

よくある例は、JSONとして保存された再利用可能な著者プロフィールや、同じコレクションに保存された関連投稿URLを参照するブログ投稿です。

```ts
import { defineCollection, reference, z } from 'astro:content';

const blog = defineCollection({
  type: 'content',
  schema: z.object({
    title: z.string(),
    // `authors` コレクションから `id` で1人の著者を参照
    author: reference('authors'),
    // `blog`コレクションから`slug`による関連記事の配列を参照
    relatedPosts: z.array(reference('blog')),
  })
});

const authors = defineCollection({
  type: 'data',
  schema: z.object({
    name: z.string(),
    portfolio: z.string().url(),
  })
});

export const collections = { blog, authors };
```

This example blog post specifies the `slug`s of related posts and the `id` of the post author:

このブログ記事の例では、関連記事の`slug`と投稿者の`id`を指定しています。

```yaml title="src/content/blog/welcome.md"
---
title: "Welcome to my blog"
author: ben-holmes # `src/content/authors/ben-holmes.json`を参照
relatedPosts:
- about-me # `src/content/blog/about-me.md`を参照
- my-year-in-review # `src/content/blog/my-year-in-review.md`を参照
---
```

### Defining custom slugs

### カスタムスラグの定義

When using `type: 'content'`, every content entry generates a URL-friendly `slug` property from its [file `id`](/en/reference/api-reference/#id). The slug is used to query the entry directly from your collection. It is also useful when creating new pages and URLs from your content.

`type: 'content'`を使用している場合、すべてのコンテンツエントリーは[ファイル`id`](/en/reference/api-reference/#id)からURLフレンドリーな`slug`プロパティを生成します。このスラグは、コレクションからエントリーを直接クエリするために使用されます。また、コンテンツから新しいページやURLを作成するときにも便利です。

You can override an entry's generated slug by adding your own `slug` property to the file frontmatter. This is similar to the "permalink" feature of other web frameworks. `"slug"` is a special, reserved property name that is not allowed in your custom collection `schema` and will not appear in your entry's `data` property. 

ファイルのフロントマターに独自の`slug`プロパティを追加すると、エントリーの生成されたスラッグをオーバーライドできます。これは他のWebフレームワークの"permalink"機能に似ています。`"slug"`は特別な予約されたプロパティ名で、カスタムコレクション`schema`では許可されず、エントリーの`data`プロパティには表示されません。

```md {3}
---
title: 私のブログ記事
slug: my-custom-slug/supports/slashes
---
あなたのブログ記事の内容はこちら。
```

## Querying Collections

## コレクションのクエリ

Astro provides two functions to query a collection and return one (or more) content entries: [`getCollection()`](/en/reference/api-reference/#getcollection) and [`getEntry()`](/en/reference/api-reference/#getentry).

Astroには、コレクションにクエリを発行して1つ (または複数) のコンテンツエントリーを返す関数が2つあります。

```js
import { getCollection, getEntry } from 'astro:content';

// Get all entries from a collection.
// Requires the name of the collection as an argument.
// Example: retrieve `src/content/blog/**`

// コレクションからすべてのエントリーを取得します。
// 引数としてコレクション名が必要です。
// 例: `src/content/blog/**`を取得する。
const allBlogPosts = await getCollection('blog');

// Get a single entry from a collection.
// Requires the name of the collection and either
// the entry `slug` (content collections) or `id` (data collections)
// Example: retrieve `src/content/authors/grace-hopper.json`

// コレクションから単一のエントリーを取得します。
// コレクションの名前と、以下のいずれかが必要です。
// エントリーの`slug`（コンテンツコレクション）または`id`（データコレクション）を指定する。
// 例: `src/content/authors/grace-hopper.json`を取得する。
const graceHopperProfile = await getEntry('authors', 'grace-hopper');
```

Both functions return content entries as defined by the [`CollectionEntry`](/en/reference/api-reference/#collection-entry-type) type.

どちらの関数も、[`CollectionEntry`](/en/reference/api-reference/#collection-entry-type)型で定義されたコンテンツエントリーを返します。

### Accessing referenced data

### 参照データへのアクセス

Any [references defined in your schema](#defining-collection-references) must be queried separately after first querying your collection entry. You can use the `getEntry()` function again, or `getEntries()`, to retrieve the referenced entry from the returned `data` object. 

[スキーマで定義されている参照](#defining-collection-references)は、最初にコレクションエントリーをクエリした後で、個別にクエリする必要があります。`getEntry()`関数を再度使用するか、または`getEntries()`を使用して、返された`data`オブジェクトから参照されるエントリーを取得できます。

```astro title="src/pages/blog/welcome.astro"
---
import { getEntry, getEntries } from 'astro:content';

const blogPost = await getEntry('blog', 'welcome');

// 単一参照の解決
const author = await getEntry(blogPost.data.author);
// 参照の配列を解決
const relatedPosts = await getEntries(blogPost.data.relatedPosts);
---

<h1>{blogPost.data.title}</h1>
<p>著者: {author.data.name}</p>

<!-- ... -->

<h2>次もおすすめ</h2> 
{relatedPosts.map(p => (
  <a href={p.slug}>{p.data.title}</a>
))}
```

### Filtering collection queries

### コレクションクエリのフィルタリング

`getCollection()` takes an optional "filter" callback that allows you to filter your query based on an entry's `id` or `data` (frontmatter) properties. For collections of `type: 'content'`, you can also filter based on `slug`.

`getCollection()`はオプションの"filter"コールバックを受け取り、エントリーの`id` や`data`（フロントマター）プロパティに基づいてクエリをフィルタリングします。`type: 'content'`のコレクションについては、`slug`に基づいてフィルタリングもできます。

:::note
The `slug` property is specific to content collections, and will not be available when filtering collections of JSON or YAML.

`slug`プロパティはコンテンツ・コレクションに固有のもので、JSONやYAMLのコレクションをフィルタリングするときには利用できません。
:::

You can use this to filter by any content criteria you like. For example, you can filter by properties like `draft` to prevent any draft blog posts from publishing to your blog:

これを使用して、好きなコンテンツ基準でフィルタリングできます。たとえば、`draft`のようなプロパティでフィルタリングして、下書きのブログ記事がブログに公開されないようにできます：

```js
// 例: `draft: true`を含むエントリーを除外
import { getCollection } from 'astro:content';
const publishedBlogEntries = await getCollection('blog', ({ data }) => {
  return data.draft !== true;
});
```

The filter argument also supports filtering by nested directories within a collection. Since the `id` includes the full nested path, you can filter by the start of each `id` to only return items from a specific nested directory:

filterの引数は、コレクション内の入れ子ディレクトリによるフィルタリングもサポートします。`id`にはネストされた完全なパスが含まれるので、各`id`の先頭でフィルタリングして、特定のネストされたディレクトリからのアイテムだけを返せます。

```js
// 例：コレクション内のサブディレクトリによるエントリーのフィルタリング
import { getCollection } from 'astro:content';
const englishDocsEntries = await getCollection('docs', ({ id }) => {
  return id.startsWith('en/');
});
```

### Using content in Astro templates

### Astroテンプレートでのコンテンツの使用

Once you have queried your collection entries, you can access each entry directly inside of your Astro component template. This lets you to render HTML for things like links to your content (using the content `slug`) or information about your content (using the `data` property).

コレクションエントリーをクエリすると、Astroコンポーネントテンプレートの内部で各エントリーに直接アクセスできます。これにより、コンテンツへのリンク（contentslugを使用）やコンテンツに関する情報（dataプロパティを使用）などのHTMLをレンダリングできます。

For information about rendering your content to HTML, see [Rendering Content to HTML](/en/guides/content-collections/#rendering-content-to-html) below.

コンテンツをHTMLにレンダリングする方法については、下記の[コンテンツをHTMLにレンダリングする](/en/guides/content-collections/#rendering-content-to-html)を参照してください。

```astro
---
// src/pages/index.astro
import { getCollection } from 'astro:content';
const blogEntries = await getCollection('blog');
---
<ul>
  {blogEntries.map(blogPostEntry => (
    <li>
      <a href={`/my-blog-url/${blogPostEntry.slug}`}>{blogPostEntry.data.title}</a>
      <time datetime={blogPostEntry.data.publishedDate.toISOString()}>
        {blogPostEntry.data.publishedDate.toDateString()}
      </time>
    </li>
  ))}
</ul>
```

### Passing content as props

### コンテンツをpropsとして渡す

A component can also pass an entire content entry as a prop. 

コンポーネントは、コンテンツエントリー全体をプロパティとして渡すこともできます。

If you do this, you can use the [`CollectionEntry`](/en/reference/api-reference/#collection-entry-type) utility to correctly type your components props using TypeScript.  This utility takes a string argument that matches the name of your collection schema, and will inherit all of the properties of that collection's schema.

そうすれば、[`CollectionEntry`](/en/reference/api-reference/#collection-entry-type)ユーティリティを使用して、TypeScriptを使用してコンポーネントのpropを正しくタイプすることができます。 このユーティリティは、コレクションスキーマの名前と一致する文字列引数を取り、そのコレクションのスキーマのすべてのプロパティを継承します。

```astro /CollectionEntry(?:<.+>)?/
---
// src/components/BlogCard.astro
import type { CollectionEntry } from 'astro:content';
interface Props {
  post: CollectionEntry<'blog'>;
}

// `post`は'blog'コレクションのスキーマタイプにマッチする。
const { post } = Astro.props;
---
```

### Rendering content to HTML

### コンテンツをHTMLにレンダリングする

Once queried, you can render Markdown and MDX entries to HTML using the entry `render()` function property. Calling this function gives you access to rendered content and metadata, including both a `<Content />` component and a list of all rendered headings.

クエリされると、エントリーの`render()`関数プロパティを使用して、MarkdownおよびMDXエントリーをHTMLにレンダリングできます。この関数を呼び出すと、`<Content />`コンポーネントとレンダリングされたすべての見出しのリストを含む、レンダリングされたコンテンツとメタデータにアクセスできます。

```astro {5}
---
// src/pages/render-example.astro
import { getEntry } from 'astro:content';
const entry = await getEntry('blog', 'post-1');
const { Content, headings } = await entry.render();
---
<p>公開日: {entry.data.published.toDateString()}</p>
<Content />
```


## Generating Routes from Content

## コンテンツからルーティングを生成

Content collections are stored outside of the `src/pages/` directory. This means that no routes are generated for your collection items by default. You will need to manually create a new [dynamic route](/en/core-concepts/routing/#dynamic-routes) to generate HTML pages from your collection entries. Your dynamic route will map the incoming request param (ex: `Astro.params.slug` in `src/pages/blog/[...slug].astro`) to fetch the correct entry inside a collection.

コンテンツコレクションは`src/pages/`ディレクトリの外に保存されます。つまり、デフォルトではコレクション項目に対してルートは生成されません。コレクション項目から HTML ページを生成するには、手動で新しい[動的ルーティング](/en/core-concepts/routing/#dynamic-routes)を作成する必要があります。動的ルーティングは、リクエストのパラメーター (例:`src/pages/blog/[...slug].astro`の`Astro.params.slug`) をマッピングして、コレクション内の正しいエントリーを取得します。

The exact method for generating routes will depend on your build [`output`](/en/reference/configuration-reference/#output) mode: 'static' (the default) or 'server' (for SSR).

ルーティングを生成する正確な方法は、ビルドの[出力](/en/reference/configuration-reference/#output)モードによって異なります: 'static'(デフォルト)または'server'(SSRの場合)。

### Building for static output (default)

### 静的出力の構築（デフォルト）

If you are building a static website (Astro's default behavior), you would use the [`getStaticPaths()`](/en/reference/api-reference/#getstaticpaths) function to create multiple pages from a single `src/pages/` component during your build.

静的なウェブサイトを構築する場合（Astroのデフォルトの動作）、ビルド中に1つの`src/pages/`コンポーネントから複数のページを作成するには、[`getStaticPaths()`](/en/reference/api-reference/#getstaticpaths)関数を使用します。


Call [`getCollection()`](/en/reference/api-reference/#getcollection) inside of `getStaticPaths()` to query your content. Then, create your new URL paths using the `slug` property of each content entry.

`getStaticPaths()`内で[`getCollection()`](/en/reference/api-reference/#getcollection) を呼び出し、コンテンツをクエリします。それから、各コンテンツエントリーの`slug`プロパティを使用して、新しいURLパスを作成します。

```astro "{ slug: entry.slug }"
---
// src/pages/posts/[...slug].astro
import { getCollection } from 'astro:content';
// 1. Generate a new path for every collection entry
// 1. コレクションエントリーごとに新しいパスを生成
export async function getStaticPaths() {
  const blogEntries = await getCollection('blog');
  return blogEntries.map(entry => ({
    params: { slug: entry.slug }, props: { entry },
  }));
}
// 2. For your template, you can get the entry directly from the prop
// 2. テンプレートでは、プロップからエントリーを直接取得できる
const { entry } = Astro.props;
const { Content } = await entry.render();
---
<h1>{entry.data.title}</h1>
<Content />
```

This will generate a new page for every entry in the `blog` collection. For example, an entry at `src/content/blog/hello-world.md` will have a slug of `hello-world`, and therefore its final URL will be `/posts/hello-world/`.

これにより、ブログ・コレクションの各エントリーに新しいページが生成されます。例えば、src/content/blog/hello-world.mdのエントリーはhello-worldというスラッグを持つので、最終的なURLは/posts/hello-world/となります。

:::note
If your custom slugs contain the `/` character to produce URLs with multiple path segments, you must use a [rest parameter (`[...slug]`)](/en/core-concepts/routing/#rest-parameters) in the `.astro` filename for this dynamic routing page.

カスタムスラッグに/文字が含まれ、複数のパスセグメントを持つURLを生成する場合は、このダイナミックルーティングページの.astroファイル名にrestパラメータ（[...slug]）を使用する必要があります。
:::

### Building for server output (SSR)

### サーバー出力のための構築（SSR）

If you are building a dynamic website (using Astro's SSR support), you are not expected to generate any paths ahead of time during the build. Instead, your page should examine the request (using `Astro.request` or `Astro.params`) to find the `slug` on-demand, and then fetch it using [`getEntry()`](/en/reference/api-reference/#getentry).

動的なウェブサイトを構築する場合（AstroのSSRサポートを使用する場合）、ビルド時にパスを生成する必要はありません。そのかわり、ページでは（`Astro.request`あるいは`Astro.params`を使って）リクエストを調べて`slug`を見つけ、[`getEntry()`](/en/reference/api-reference/#getentry)を使って取得しなければなりません。


```astro
---
// src/pages/posts/[...slug].astro
import { getEntry } from "astro:content";
// 1. Get the slug from the incoming server request
// 1. 受信サーバーのリクエストからスラッグを取得
const { slug } = Astro.params;
if (slug === undefined) {
	throw new Error("Slug is required");
}
// 2. Query for the entry directly using the request slug
// 2. リクエストスラッグを使ってエントリーを直接検索
const entry = await getEntry("blog", slug);
// 3. Redirect if the entry does not exist
// 3. エントリーが存在しない場合はリダイレクト
if (entry === undefined) {
	return Astro.redirect("/404");
}
// 4. (Optional) Render the entry to HTML in the template
// 4. (オプション) テンプレート内でエントリーをHTMLにレンダリング
const { Content } = await entry.render();
---
```

## Migrating from File-Based Routing 

## ファイルベースのルーティングからの移行

This guide shows you how to convert an existing Astro project with Markdown files in the `src/pages/` folder to content collections. It uses the [Build a Blog tutorial's finished project](https://github.com/withastro/blog-tutorial-demo) as an example.

このガイドでは、`src/pages/`フォルダにMarkdownファイルがある既存のAstroプロジェクトをコンテンツコレクションに変換する方法を紹介します。[ブログを作る](https://github.com/withastro/blog-tutorial-demo)チュートリアルの完成したプロジェクトを例として使用しています。

1. [Upgrade](/en/guides/upgrade-to/v2/) to Astro v2.0 or later, and upgrade all integrations to their latest versions. 

1. Astro v2.0以降に[アップグレード](/en/guides/upgrade-to/v2/)し、すべてのインテグレーションを最新バージョンにアップグレードしてください。

2. [Set up TypeScript](/en/guides/content-collections/#setting-up-typescript) for content collections.

2. コンテンツコレクションに[TypeScriptを設定](/en/guides/content-collections/#setting-up-typescript))する。

3. Create at least one collection (folder in `src/content/`) and move your Markdown and MDX pages from `src/pages/` into these subdirectories of `src/content/`. Collections work best when all files in the same collection have similar frontmatter properties. So, choose your new folder structure to reflect similar types of pages.

3. 少なくとも1つのコレクション（`src/content/`内のフォルダ）を作成し、MarkdownページとMDXページを`src/pages/`から `src/content/`のこれらのサブディレクトリに移動します。コレクションは、同じコレクション内のすべてのファイルのフロントマタープロパティが似ている場合に、もっともうまく機能します。ですから、同じようなタイプのページを反映するように、新しいフォルダ構造を選択してください。

    For example, to migrate the [blog posts in the tutorial](/en/tutorial/2-pages/2/), move the contents of `src/pages/posts/` to `src/content/posts/`. 
    
    たとえば、[チュートリアルのブログ記事](/en/tutorial/2-pages/2/)を移行するには、`src/pages/posts/`の内容を`src/content/posts/`に移動します。

4. Create a `src/content/config.ts` file and [define a schema](/en/guides/content-collections/#defining-a-collection-schema) for each content type. For the blog, we only have one content type, `posts`:

4. `src/content/config.ts`ファイルを作成し、各コンテンツタイプのスキーマを定義します。ブログの場合、コンテンツタイプは`posts`だけです。

    ```ts title="src/content/config.ts"
    // Import utilities from `astro:content`
    import { z, defineCollection } from "astro:content";
    // Define a `type` and `schema` for each collection
    const postsCollection = defineCollection({
        type: 'content',
        schema: z.object({
          title: z.string(),
          pubDate: z.date(),
          description: z.string(),
          author: z.string(),
          image: z.object({
            url: z.string(),
            alt: z.string()
          }),
          tags: z.array(z.string())
        })
    });
    // Export a single `collections` object to register your collection(s)
    export const collections = {
      posts: postsCollection,
    };
    ```

    :::tip
    If your editor doesn't recognize `astro:content`, make sure you're on the latest version of Astro and try restarting the dev server. 
    
    エディターが`astro:content`を認識しない場合は、Astroが最新バージョンであることを確認し、開発サーバーを再起動してみてください。
    :::


5. [Generate routes from your collections](/en/guides/content-collections/#generating-routes-from-content). Inside a collection, Markdown and MDX files no longer automatically become pages using Astro's [file-based routing](/en/guides/markdown-content/#file-based-routing), so you must generate the pages yourself.

5. [コレクションからルートを生成します](/en/guides/content-collections/#generating-routes-from-content)。コレクション内では、MarkdownファイルやMDXファイルは、Astroの[ファイルベースのルーティング](/en/guides/markdown-content/#file-based-routing)を使用しても自動的にページにならないため、自分でページを生成する必要があります。

    For the tutorial, create a `src/pages/posts/[...slug].astro`. This page will use [dynamic routing](/en/core-concepts/routing/#dynamic-routes) to generate a page for each collection entry. 
    
    チュートリアルでは、`src/pages/posts/[...slug].astro`を作成します。このページは動的ルーティングを使用して、各コレクションのエントリーのページを生成します。

    This page will also need to [query your collection](#querying-collections) to fetch page slugs and make the page content available to each route.
    
    このページはまた、ページスラグを取得し、各ルートでページコンテンツを利用できるようにするために、[コレクションに問い合わせる](#querying-collections)必要があります。

    Render your post `<Content />` within the layout for your Markdown or MDX pages. This allows you to specify a common layout for all of your posts.
    
    投稿の`<Content />`を、MarkdownまたはMDXページのレイアウト内にレンダリングします。これにより、すべての投稿に共通のレイアウトを指定できます。

    ```astro title="src/pages/posts/[...slug].astro"
    ---
    import { getCollection } from 'astro:content';
    import MarkdownPostLayout from '../../layouts/MarkdownPostLayout.astro';

    export async function getStaticPaths() {
      const blogEntries = await getCollection('posts');
      return blogEntries.map(entry => ({
        params: { slug: entry.slug }, props: { entry },
      }));
    }

    const { entry } = Astro.props;
    const { Content } = await entry.render();
    ---
    <MarkdownPostLayout frontmatter={entry.data}>
      <Content />
    </MarkdownPostLayout>
    ```

6. Remove the `layout` definition in each individual post's frontmatter. Your content is now wrapped in a layout when rendered, and this property is no longer needed.

6. 個々の投稿のフロントマター内の`layout`定義を削除します。レンダリング時にコンテンツがレイアウトに包まれるようになり、このプロパティは不要になりました。

    ```md title="src/content/post-1.md" del={2}
    ---
    layout: ../../layouts/MarkdownPostLayout.astro
    title: 'はじめてのブログ記事'
    pubDate: 2022-07-01
    ...
    ---
    ```

7. Replace `Astro.glob()` with [`getCollection()`](/en/reference/api-reference/#getcollection) to fetch content and metadata from your Markdown files. You will also need to update references to the returned post object, since you will now find your frontmatter values on the `data` property.

7. `Astro.glob()`を[`getCollection()`](/en/reference/api-reference/#getcollection)に置き換えて、Markdownファイルからコンテンツとメタデータを取得します。返された post オブジェクトへの参照も更新する必要があります。

    The blog index page in the tutorial lists a card for each post. This becomes:
    
    チュートリアルのブログのインデックスページには、各記事のカードがリストアップされています。これは次のようになります。

    ```astro title="src/pages/blog.astro" "post.data" "getCollection(\"posts\")" "'/posts/' + post.slug"
    ---
    import { getCollection } from "astro:content";
    import BaseLayout from "../layouts/BaseLayout.astro";
    import BlogPost from "../components/BlogPost.astro";

    const pageTitle = "My Astro Learning Blog";
    const allPosts = await getCollection("posts");
    ---

    <BaseLayout pageTitle={pageTitle}>
      <p>This is where I will post about my journey learning Astro.</p>
      <ul>
        {
          allPosts.map((post) => (
            <BlogPost url={'/posts/' + post.slug} title={post.data.title} />
          ))
        }
      </ul>
    </BaseLayout> 
    ```

    The tutorial blog project also dynamically generates a page for each tag. This page now becomes:
    
    チュートリアルのブログのプロジェクトは、各タグのページも動的に生成します。このページは現在次のようになります。

    ```astro title="src/pages/tags/[tag].astro" "post.data" "getCollection(\"posts\")" "post.data.title" "'/posts/' + post.slug"
    ---
    import { getCollection } from "astro:content";
    import BaseLayout from "../../layouts/BaseLayout.astro";
    import BlogPost from "../../components/BlogPost.astro";

    export async function getStaticPaths() {
      const allPosts = await getCollection("posts");
      const uniqueTags = [...new Set(allPosts.map((post) => post.data.tags).flat())];

      return uniqueTags.map((tag) => {
        const filteredPosts = allPosts.filter((post) =>
          post.data.tags.includes(tag)
        );
        return {
          params: { tag },
          props: { posts: filteredPosts },
        };
      });
    }
    
    const { tag } = Astro.params;
    const { posts } = Astro.props;
    ---

    <BaseLayout pageTitle={tag}>
        <p>Posts tagged with {tag}</p>
        <ul>
            { posts.map((post) => <BlogPost url={'/posts/' + post.slug} title={post.data.title} />) }
        </ul>
    </BaseLayout>
    ```

    The same logic appears in the tag index page, which becomes:
    
    同じロジックがタグインデックスページにも現れています。次のようになります。
    
    ```astro title="src/pages/tags/index.astro" "post.data" "getCollection(\"posts\")"
    ---
    import { getCollection } from "astro:content";
    import BaseLayout from "../../layouts/BaseLayout.astro";
    const allPosts = await getCollection("posts");
    const tags = [...new Set(allPosts.map((post) => post.data.tags).flat())];
    const pageTitle = "Tag Index";
    ---
    ...
    ```

    :::note
    Any individual Markdown or MDX file imports should be replaced by [`getEntry()`](/en/reference/api-reference/#getentry).
    
    個々のMarkdownやMDXファイルのインポートは、[`getEntry()`](/en/reference/api-reference/#getentry)で置き換える必要があります。
    :::
    
8. Update the code that uses the publish date in the `layouts/MarkdownPostLayout.astro` file.
8. `layouts/MarkdownPostLayout.astro`ファイルの公開日を使用するコードを更新しました。

    Previously, `pubDate` was a string. Now, after introducing types for your posts' frontmatter, `pubDate` is a `Date`.
    To render the date, convert it to a string:
    以前は、`pubDate`は文字列でした。投稿のフロントマターに型を導入した結果、`pubDate`は`Date`になりました。 日付をレンダリングするには、文字列に変換します。

    ```astro title="src/layouts/MarkdownPostLayout.astro" "frontmatter.pubDate.toDateString()"
    ...
    <BaseLayout pageTitle={frontmatter.title}>
      <p>{frontmatter.pubDate.toDateString()}</p>
      <p><em>{frontmatter.description}</em></p>
      <p>Written by: {frontmatter.author}</p>
      <img src={frontmatter.image.url} width="300" alt={frontmatter.image.alt} />
    ...
    ```
    

    Lastly, the tutorial blog project includes an RSS feed. This function must also use `getCollection` and the `data` object, and be converted to an async function to do so:
    
    最後に、チュートリアルのブログプロジェクトにはRSSフィードが含まれています。この関数も`getCollection`と`data`オブジェクトを使用し、非同期関数に変換する必要があります。

    ```js title="src/pages/rss.xml.js" {4-5, 10-15} 
    import rss from "@astrojs/rss";
    import { getCollection } from "astro:content";

    export async function get() {
      const posts = await getCollection('posts');
      return rss({
        title: 'Astro Learner | Blog',
        description: 'My journey learning Astro',
        site: 'https://my-blog-site.netlify.app',
        items: posts.map((post) => ({
          title: post.data.title,
          pubDate: post.data.pubDate,
          description: post.data.description,
          link: `/posts/${post.slug}/`,
        })),
        customData: `<language>en-us</language>`,
      });
    }
    ```

For the full example of the blog tutorial using content collections, see the [Content Collections branch](https://github.com/withastro/blog-tutorial-demo/tree/content-collections) of the tutorial repo.

コンテンツコレクションを使用したブログチュートリアルの完全な例については、チュートリアルリポジトリのコンテンツコレクションのブランチを参照してください。

## Modifying Frontmatter with Remark
## Remarkでフロントマターを修正

:::caution
**Not recommended.** Remark and rehype plugins access the _raw_ Markdown or MDX document frontmatter. This means that `remarkPluginFrontmatter` frontmatter is handled separately from your type-safe `schema`, and will not reflect any changes or defaults applied through Astro. Use at your own risk!

**非推奨。**Remarkとrehypeプラグインは生のMarkdownまたはMDXドキュメントのフロントマターにアクセスします。これは`remarkPluginFrontmatter`のフロントマターがあなたの型セーフスキーマとは別に扱われ、Astroを通して適用された変更やデフォルトは反映されません。使用は自己責任です！
:::

Astro supports remark or rehype plugins that [modify your frontmatter directly](/en/guides/markdown-content/#modifying-frontmatter-programmatically). You can access this modified frontmatter inside of a content entry by using the `remarkPluginFrontmatter` property returned from `render()`:

Astro は、[フロントマターを直接変更する](/en/guides/markdown-content/#modifying-frontmatter-programmatically)remarkまたはrehypeプラグインをサポートしています。`render()`から返される`remarkPluginFrontmatter`プロパティを使うと、コンテンツエントリー内でこの変更されたフロントマターにアクセスできます。

```astro "{ remarkPluginFrontmatter }"
---
import { getEntry } from 'astro:content';
const blogPost = await getEntry('blog', 'post-1');
const { remarkPluginFrontmatter } = await blogPost.render();
---
<p>{blogPost.data.title} — {remarkPluginFrontmatter.readingTime}</p>
```

<RecipeLinks slugs={["en/recipes/reading-time" ]}/>

The remark and rehype pipelines only run when your content is rendered, which explains why `remarkPluginFrontmatter` is only available after you call `render()` on your content entry. In contrast, `getCollection()` and `getEntry()` cannot return these values directly because they do not render your content.

remarkやrehypeのパイプラインは、コンテンツがレンダリングされたときにのみ実行されます。そのため、`render()`をコールした後に`remarkPluginFrontmatter`を使用できるようになります。対照的に、`getCollection()`や`getEntry()`はコンテンツをレンダリングしないので、これらの値を直接返すことはできません。
